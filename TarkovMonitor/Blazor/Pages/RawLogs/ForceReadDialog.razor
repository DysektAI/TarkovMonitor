@* 
    ForceReadDialog.razor
    This component provides a dialog interface for reading and processing historical game logs
    from Escape from Tarkov. It allows users to select a previous point in time to read logs
    and update their quest progress in Tarkov Tracker.

    Dependencies:
    - MessageLog: Service for displaying messages to the user
    - GameWatcher: Service for monitoring the game state
*@

@using System.ComponentModel
@using Humanizer
@inject MessageLog messageLog
@inject GameWatcher eft
@implements IDisposable

<MudDialog>
    <DialogContent>
        @* Display current profile information to help user verify correct profile selection *@
        <MudText>
            Current profile: @eft.CurrentProfile.Id (@eft.CurrentProfile.Type)
        </MudText>
        <MudText>
            If you want to update progress for a different profile, activate that profile in the game.
        </MudText>
        @* Only show log selection if we have a valid logs path *@
        @if (customWatcher.LogsPath != "")
        {
            if (breakpoints != null)
            {
                @* Dropdown to select the starting point for log reading *@
                <MudSelect @bind-Value="selectedBreakpoint" Label="Read previous logs"
                    HelperText="Choose the starting point from which to read logs" OpenIcon="@Icons.Material.Filled.TextSnippet"
                    AdornmentColor="Color.Secondary">
                    @foreach (LogDetails breakpoint in breakpoints)
                    {
                        <MudSelectItem Value="@breakpoint">@breakpoint.Version | @breakpoint.Date.ToLongDateString() -
                            @breakpoint.Date.Humanize()</MudSelectItem>
                    }
                </MudSelect>
                <p>Select a starting point to read previous logs and update your quest progress. All logs from that point
                    forward for the same will be read and that cumulative progress will be synced to Tarkov Tracker.</p>
                <p><strong>WARNING: </strong>You can mess up your Tarkov Tracker saved quest progress if you pick an invalid
                    starting date, so proceed with caution.</p>
            }
            else
            {
                @* Show loading indicator while fetching breakpoints *@
                <MudProgressCircular Color="Color.Info" Indeterminate="true" />
            }
        }
        else
        {
            <span>Could not find the Escape From Tarkov installation location, or no logs exist.</span>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Primary" OnClick="Submit">Ok</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] MudDialogInstance? MudDialog { get; set; }

    // Custom watcher instance for processing game logs
    internal GameWatcher customWatcher = new();

    // Selected breakpoint for log processing
    LogDetails? selectedBreakpoint;

    // List of available log breakpoints
    List<LogDetails>? breakpoints;

    // Dictionary to track task status changes
    Dictionary<string, TarkovMonitor.TaskStatus> TaskStatuses = new();

    // Event handler for property changes
    private PropertyChangedEventHandler? propertyChangedHandler;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Initialize breakpoints asynchronously
        Task.Run(GetBreakPoints);

        // Set up property change handler for custom logs path
        propertyChangedHandler = (object? sender, PropertyChangedEventArgs e) =>
        {
            if (e.PropertyName == "customLogsPath")
            {
                customWatcher.LogsPath = Properties.Settings.Default.customLogsPath;
                Task.Run(GetBreakPoints);
            }
        };
        Properties.Settings.Default.PropertyChanged += propertyChangedHandler;
    }

    // Fetches available log breakpoints for the current profile
    private void GetBreakPoints()
    {
        breakpoints = customWatcher.GetLogBreakpoints(eft.CurrentProfile.Id);
        InvokeAsync(() => StateHasChanged());
    }

    // Handles dialog cancellation
    void Cancel() => MudDialog?.Cancel();

    // Processes the selected logs and updates Tarkov Tracker
    public async Task Submit()
    {
        if (MudDialog == null) return;

        // Validate selection and Tarkov Tracker token
        if (selectedBreakpoint == null)
        {
            return;
        }
        if (!TarkovTracker.ValidToken)
        {
            messageLog.AddMessage("You must have a valid Tarkov Tracker API token to read past logs.", "exception");
            return;
        }

        // Clear previous task statuses and prepare for updates
        TaskStatuses.Clear();
        Dictionary<string, TarkovMonitor.TaskStatus> updateTasks = new();

        try
        {
            // Process logs and track task modifications
            customWatcher.TaskModified += UpdateTaskStatus;
            try
            {
                await customWatcher.ProcessLogsFromBreakpoint(selectedBreakpoint);
            }
            finally
            {
                customWatcher.TaskModified -= UpdateTaskStatus;
            }

            // Compare and prepare task updates
            foreach (var kvp in TaskStatuses)
            {
                if (kvp.Value == TarkovMonitor.TaskStatus.Started)
                {
                    // Skip tasks that are only started
                    continue;
                }

                var task = TarkovDev.Tasks.Find((t) => t.Id == kvp.Key);
                if (task == null)
                {
                    // Skip daily tasks or unknown tasks
                    continue;
                }

                // Get current task status from Tarkov Tracker
                TarkovMonitor.TaskStatus savedTaskStatus = TarkovMonitor.TaskStatus.None;
                var taskProgress = TarkovTracker.Progress.Data.TasksProgress.Find((prog) => prog.Id == kvp.Key);
                if (taskProgress != null)
                {
                    if (taskProgress.Failed)
                    {
                        savedTaskStatus = TarkovMonitor.TaskStatus.Failed;
                    }
                    if (taskProgress.Complete)
                    {
                        savedTaskStatus = TarkovMonitor.TaskStatus.Finished;
                    }
                }

                // Only update if status has changed
                if (kvp.Value == savedTaskStatus)
                {
                    continue;
                }

                // Add task to update queue and log the change
                updateTasks.Add(kvp.Key, kvp.Value);
                messageLog.AddMessage($"{kvp.Value} task {task.Name}", "quest", $"https://tarkov.dev/task/{task.NormalizedName}");
            }
        }
        catch (Exception ex)
        {
            messageLog.AddMessage($"Error finding task updates: {ex.Message}", "exception");
            return;
        }

        // Submit updates to Tarkov Tracker
        try
        {
            if (updateTasks.Count > 0)
            {
                await TarkovTracker.SetTaskStatuses(updateTasks);
                messageLog.AddMessage($"Updated status of {updateTasks.Count} tasks in Tarkov Tracker.", "info");
            }
            else
            {
                messageLog.AddMessage("No tasks found in past logs that require updating in Tarkov Tracker.", "info");
            }
            MudDialog.Close(DialogResult.Ok(true));
        }
        catch (Exception ex)
        {
            messageLog.AddMessage($"Error updating tasks: {ex.Message}", "exception");
        }
    }

    // Event handler for task status updates
    private void UpdateTaskStatus(object? sender, LogContentEventArgs<TaskStatusMessageLogContent> e)
    {
        if (e.LogContent?.TaskId != null)
        {
            TaskStatuses[e.LogContent.TaskId] = e.LogContent.Status;
        }
    }

    // Cleanup event handlers on component disposal
    public void Dispose()
    {
        if (propertyChangedHandler != null)
        {
            Properties.Settings.Default.PropertyChanged -= propertyChangedHandler;
        }
    }
}